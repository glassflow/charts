# Default values for glassflow-etl.
# This is a YAML-formatted file.
# Declare variables to be passed into your templates.

# =============================================================================
# GLOBAL SETTINGS
# =============================================================================
# Global settings that apply across all components of the chart
global:
  # Global image registry - if set, will be prepended to all image repositories
  imageRegistry: "ghcr.io/glassflow/"
  observability:
    metrics:
      enabled: true
    logs:
      enabled: false
      exporter:
        otlp: {}
  nats:
    # NATS address for the operator to connect to
    # Defaults to {{ .Release.Name }}-nats.{{ .Release.Namespace }}.svc.cluster.local:4222 if not specified
    # address: ""
    stream:
      maxAge: 24h
      maxBytes: 10GB

  # Pipelines namespace configuration
  pipelines:
    namespace:
      # When true, operator creates per-pipeline namespaces (pipeline-<id>)
      auto: true
      # When auto is false, the fixed namespace to deploy all pipelines into
      name: glassflow-pipelines
      # When auto is false, Helm can optionally create the namespace and add label managed-by=helm
      create: true

  usageStats:
    enabled: true
  # PostgreSQL connection URL
  # Only used when postgresql.enabled is false
  # Format: postgresql://username:password@host:port/database
  # postgres_connection_url: ""
# =============================================================================
# API COMPONENT CONFIGURATION
# =============================================================================
# Backend API service configuration for the GlassFlow ETL application
api:
  replicas: 1
  logLevel: "info"
  image:
    repository: glassflow-etl-be
    tag: v2.6.0
    pullPolicy: IfNotPresent
  resources:
    requests:
      memory: "100Mi"  # Memory request - adjust based on your workload
      cpu: "100m"      # CPU request - adjust based on your workload
    # Maximum resources the API pods can use
    limits:
      memory: "200Mi"    # Memory limit - adjust based on your workload
      cpu: "250m"      # CPU limit - adjust based on your workload

  service:
    type: ClusterIP
    port: 8081
    targetPort: 8081

  # Environment variables for the API service
  # Supported variables:
  # - GLASSFLOW_LOG_FILE_PATH: Path to the log file (Default: /tmp/logs/glassflow)
  # - GLASSFLOW_LOG_LEVEL: Log level (Default: INFO)
  # Example:
  # env:
  #   - name: GLASSFLOW_LOG_LEVEL
  #     value: "DEBUG"
  env: []

# =============================================================================
# UI COMPONENT CONFIGURATION
# =============================================================================
# Frontend UI service configuration for the GlassFlow ETL application
ui:
  replicas: 1
  image:
    repository: glassflow-etl-fe
    tag: v2.6.0
    pullPolicy: IfNotPresent
  logLevel: "info"
  resources:
    requests:
      memory: "512Mi"
      cpu: "100m"
    limits:
      memory: "1Gi"
      cpu: "200m"

  service:
    type: ClusterIP
    port: 8080
    targetPort: 8080

  # Environment variables for the UI service
  # Supported variables:
  # - NEXT_PUBLIC_API_URL: API URL for the application
  # - KAFKA_GATEWAY_URL: Kafka Kerberos Gateway URL (set automatically for sidecar)
  # Example:
  # env:
  #   - name: NEXT_PUBLIC_API_URL
  #     value: "http://{{ .Release.Name }}-api.{{ .Release.Namespace }}.svc.cluster.local:8080"
  env: []

  # Auth0 configuration for authentication
  auth0:
    # Enable or disable Auth0 authentication
    enabled: false
    # Profile route endpoint (default: /api/auth/me)
    profileRoute: "/api/auth/me"
    # Auth0 secret for session encryption
    secret: ""
    # Base URL of the application (default: http://localhost:8080)
    appBaseUrl: "http://localhost:8080"
    # Auth0 domain (e.g., your-tenant.auth0.com)
    domain: ""
    # Auth0 issuer base URL
    issuerBaseUrl: ""
    # Auth0 client ID
    clientId: ""
    # Auth0 client secret
    clientSecret: ""

  # Kafka Kerberos Gateway sidecar configuration
  # This sidecar provides Kerberos authentication support for Kafka connections
  kafkaGateway:
    enabled: true
    image:
      repository: kafka-kerberos-gateway
      tag: latest
      pullPolicy: IfNotPresent
    resources:
      requests:
        memory: "128Mi"  # Memory request - gateway is lightweight
        cpu: "50m"       # CPU request - 50 millicores = 0.05 CPU cores
      # Maximum resources the gateway sidecar can use
      limits:
        memory: "256Mi"  # Memory limit - gateway doesn't need much
        cpu: "200m"      # CPU limit - 200 millicores = 0.2 CPU cores

    # Port for the gateway service (internal to pod)
    port: 8082

# =============================================================================
# GLASSFLOW OPERATOR CONFIGURATION
# =============================================================================
# Kubernetes operator for managing ETL pipelines and related resources
glassflow-operator:
  # Operator deployment configuration
  controllerManager:
    replicas: 1
    manager:
      image:
        repository: glassflow-etl-k8s-operator
        tag: v1.4.3
        pullPolicy: IfNotPresent
      resources:
        limits:
          cpu: 500m
          memory: 128Mi
        requests:
          cpu: 10m
          memory: 64Mi
    serviceAccount:
      annotations: {}

  glassflowComponents:
    ingestor:
      image:
        repository: glassflow-etl-ingestor
        tag: v2.6.0
        pullPolicy: IfNotPresent
      logLevel: "INFO"
      resources:
        requests:
          cpu: 100m
          memory: 100Mi
        limits:
          cpu: 500m
          memory: 750Mi
      # Node affinity for ingestor component (optional)
      affinity: {}
    join:
      image:
        repository: glassflow-etl-join
        tag: v2.6.0
        pullPolicy: IfNotPresent
      logLevel: "INFO"
      resources:
        requests:
          cpu: 100m
          memory: 100Mi
        limits:
          cpu: 500m
          memory: 750Mi
      # Node affinity for join component (optional)
      affinity: {}
    sink:
      image:
        repository: glassflow-etl-sink
        tag: v2.6.0
        pullPolicy: IfNotPresent
      logLevel: "INFO"
      resources:
        requests:
          cpu: 100m
          memory: 100Mi
        limits:
          cpu: 500m
          memory: 1.5Gi
      # Node affinity for sink component (optional)
      affinity: {}
    dedup:
      image:
        repository: glassflow-etl-dedup
        tag: v2.6.0
        pullPolicy: IfNotPresent
      logLevel: "INFO"
      resources:
        requests:
          cpu: 1000m
          memory: 1Gi
        limits:
          cpu: 2000m
          memory: 4Gi
      storage:
        size: "40Gi"
        className: ""
      affinity: {}
# =============================================================================
# NATS OPERATOR CONFIGURATION
# =============================================================================
# NATS prometheus exporter for getting metrics from NATS
# This is enabled when global.observability.metrics.enabled is true
natsPrometheusExporter:
  image:
    repository: natsio/prometheus-nats-exporter
    tag: 0.17.3
    pullPolicy: IfNotPresent
  metrics:
    accstatz: true
    connz: true
    connz_detailed: true
    jsz: true
    gatewayz: true
    leafz: true
    routez: true
    subz: true
    varz: true
  service:
    type: ClusterIP
    port: 80
    targetPort: 7777
    protocol: TCP
    name: http


# =============================================================================
# POSTGRESQL CONFIGURATION
# =============================================================================
# PostgreSQL database configuration
# When enabled, the postgresql dependency chart will be deployed
# When disabled, use global.postgres_connection_url to connect to an external PostgreSQL instance
postgresql:
  # Enable or disable PostgreSQL deployment
  # Set to false if you want to use an external PostgreSQL instance
  enabled: true
  # PostgreSQL configuration settings
  # These values are passed to the postgresql dependency chart
  image:
    repository: postgres
    tag: "17-alpine"
    pullPolicy: IfNotPresent

  replicaCount: 1
  auth:
    enabled: true
    database: "glassflow"
    # Please update this for production deployments
    username: "glassflow"
    password: "glassflow123"
    existingSecret:
      enabled: false
      name: ""
      keys:
        usernameKey: username
        passwordKey: password
        databaseKey: database

  service:
    type: ClusterIP
    port: 5432
    targetPort: 5432
    annotations: {}

  persistence:
    enabled: true
    size: 10Gi
  resources:
    requests:
      memory: "512Mi"
      cpu: "100m"
    limits:
      memory: "2Gi"
      cpu: "1000m"

# =============================================================================
# NATS CONFIGURATION
# =============================================================================
# NATS messaging system configuration for internal communication
nats:
  # Enable or disable NATS deployment
  # Set to false if you want to use an external NATS instance
  enabled: true
  config:
    cluster:
      enabled: true
      port: 6222
      replicas: 3
    jetstream:
      enabled: true
      memoryStore:
        enabled: false
        maxSize: 1Gi
      fileStore:
        enabled: true
        dir: /data
        pvc:
          enabled: true
          size: 100Gi
          storageClassName: ""

    resources:
      requests:
        memory: "4Gi"
        cpu: "2000m"
      limits:
        memory: "4Gi"
        cpu: "2000m"

# =============================================================================
# INGRESS CONFIGURATION
# =============================================================================
# Ingress configuration for external access to the application
ingress:
  # Enable or disable ingress
  # Set to true to expose the application externally
  enabled: false

  # Ingress class name (required for Kubernetes 1.18+)
  # Example: "nginx", "traefik", "istio"
  ingressClassName: ""

  # Annotations for the ingress resource
  # Useful for SSL termination, rate limiting, etc.
  annotations: {}

  # Host configurations for the ingress
  # Example:
  # - host: "etl.example.com"
  #   paths:
  #     - path: "/"
  #       pathType: Prefix
  #       serviceName: "glassflow-etl-ui"
  #       servicePort: 8080
  hosts: []

  # TLS configuration for HTTPS
  # Example:
  # - hosts:
  #     - "etl.example.com"
  #   secretName: "etl-tls-secret"
  tls: []

# =============================================================================
# SECURITY CONFIGURATION
# =============================================================================
# Pod and container security context settings
podSecurityContext: {}
  # fsGroup: 2000  # File system group ID

# Container security context settings
securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
  # runAsUser: 1000

# =============================================================================
# SERVICE ACCOUNT CONFIGURATION
# =============================================================================
# Service account configuration for the application (UI and API)
serviceAccount:
  # Create a new service account for the application (UI and API)
  # Set to false if you want to use an existing service account
  create: true

  # Automatically mount the service account's API credentials
  # Useful for accessing the Kubernetes API from within pods
  automount: true

  # Annotations to add to the service account
  # Useful for IAM roles, OIDC providers, etc.
  annotations: {}

  # Name of the service account to use
  # If not set and create is true, a name is generated using the fullname template
  # Example: "glassflow-etl-sa"
  name: ""

# =============================================================================
# POD CONFIGURATION
# =============================================================================
# Pod-level configuration settings
podAnnotations: {}  # Annotations to add to all pods
podLabels: {}       # Labels to add to all pods

# Node selector for main application pods (UI and API)
# Useful for scheduling pods on specific nodes
# Example:
# nodeSelector:
#   kubernetes.io/os: linux
#   node-role.kubernetes.io/worker: "true"
nodeSelector: {}

# Pod tolerations for scheduling
# Useful for running pods on nodes with taints
# Example:
# - key: "dedicated"
#   operator: "Equal"
#   value: "glassflow"
#   effect: "NoSchedule"
tolerations: []

# Pod affinity rules for scheduling
# Useful for co-locating or spreading pods
# Example:
# podAffinity:
#   requiredDuringSchedulingIgnoredDuringExecution:
#   - labelSelector:
#       matchExpressions:
#       - key: app
#         operator: In
#         values:
#         - glassflow-etl
#     topologyKey: kubernetes.io/hostname
affinity: {}

# =============================================================================
# AUTOSCALING CONFIGURATION
# =============================================================================
# Horizontal Pod Autoscaler (HPA) configuration
autoscaling:
  # Enable or disable autoscaling
  enabled: false

  # Minimum number of replicas when autoscaling
  minReplicas: 1

  # Maximum number of replicas when autoscaling
  maxReplicas: 5

  # Target CPU utilization percentage for scaling
  # HPA will scale up when CPU usage exceeds this percentage
  targetCPUUtilizationPercentage: 80

  # Target memory utilization percentage for scaling (commented out)
  # Uncomment and set a value to enable memory-based scaling
  # targetMemoryUtilizationPercentage: 80
